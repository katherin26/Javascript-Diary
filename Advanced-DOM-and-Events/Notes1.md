# **OLD WAY**

## **IMPLEMENTING SMOOTH SCROLLING**

```
We need these coordinates here to tell JavaScript where it should scroll to =
```

```
const btnScrollTo = document.querySelector('.btn--scroll-to');
const section1 = document.querySelector('#section--1');

btnScrollTo.addEventListener('click', function (e) {
const s1coords = section1.getBoundingClientRect();
console.log(
s1coords
);

//_DOMRect {x: 0, y: 276.8000183105469, width: 1524, height: 1580.425048828125, top: 276.8000183105469, …}_/

console.log(e.target.getBoundingClientRect());

//_DOMRect {x: 187, y: 194.5, width: 110, height: 27.80000114440918, top: 194.5, …}_/

console.log('Current scroll (X/Y)', window.pageXOffset, window.pageYOffset);
//Current scroll (X/Y) 0 174.39999389648438

console.log('height/width viewport',document.documentElement.clientHeight,document.documentElement.clientWidth); // height/width viewport 181 1524

```

## **Scrolling**

## **scrollTo =** That's a global function and is available on the window object.

```
window.scrollTo(
s1coords.left + window.pageXOffset,
s1coords.top + window.pageYOffset
);

//And here the first argument is the left position and that is at s1coords current position + current scroll.
```

## **Another solution**

```
And this works by passing in an object now insted of just one argument.
```

```
window.scrollTo({
left: s1coords.left + window.pageXOffset,
top: s1coords.top + window.pageYOffset,
behavior: 'smooth',
  });
});
```

## **TYPES OF EVENTS AND EVENTS HANDLERS**

```
An event is basically a signal that is generated by a certain note and a signal means that
something has happened for example , a click somewhere or the mouse moving or the user triggering the full
screen mode.
```

## **Mouseenter event**

```
const h1 = document.querySelector('h1');

//Export function into an named function

const alertH1 = function (e) {
  alert('addEventListener: great ! you are reading the heading');

  //h1.removeEventListener('mouseenter', alertH1);
};
```

```
h1.addEventListener('mouseenter', alertH1); //When we hovered over it , we got the alert.

setTimeout(() => h1.removeEventListener('mouseenter', alertH1), 3000);

h1.onmouseenter = function (e) {
alert('onmouseenter: great ! you are reading the heading');
};
```

## **BUBBLING AND CAPTURING**

```
Javascript events have a very important property, They have a so-called capturing phase and bubbling phase

<body>
  <section>
    <p>A paragraph with a <a>link</a> </p>
    <p>A second paragraph</p>
  </section>
</body>


A click happens on the LINK!
The DOM then generates a click event right away , but this event is actually not generated at the target element.
```

## **1)CAPTURING PHASE**

```
So at the element , where the event happened in this case the click on the anchor element.
Instead, the event is actually generated at the root of the document so at the very top of the DOM tree.
And from there , the so-called capturing phase happens where the event then travels all the way down from
the document root to the target element and as the event travels down the tree it will pass through every single parent element of the target element.

DOCUMENT ==> ELEMENT(html) ==> ELEMENT<body> ==> ELEMENT<section> ==> ELEMENT<p> ==> ELEMENT <a> CLICK EVENT

As soon as the event reaches the target the target phase begins , where events can be handled right at the target and as we already now , we do that with event listeners, such as this one =

document
  .querySelector('a') ====> 127.0.01:8080 says = You clicked me
  .addEventListener('click), ()=> {
    alert('You clicked me');
  });

So event listeners wait for a certain event to happen on a certain element and as soon as the event occurs, it runs the attached callback function
```

## **2) TARGET PHASE**

```
 After reaching the target the event actually travels all the way up to the document route again in the so-called =
```

## **3) BUBBLING PHASE**

```
So we say that events bubble up from the target to the document route , the event passes through all its parents elements

```

### **NOTE**

```
By default , events can only be handled in the target and in the bubbling phase, However , we can set up
event listeners in a way that they listen to events in the capturing phase instead.

Also , not all types of events have a capturing and bubbling phase some of them are created right on the target
element , and we can only handle them there
```

## **EVENT PROPAGATION IN PRACTICE**

**rgba(255,255,255)**

```
const randomInt = (min, max) =>
Math.floor(Math.random() \* (max - min + 1) + min);
const randomColor = () =>
`rgba(${randomInt(0, 255)},${randomInt(0, 255)}, ${randomInt(0, 255)})`;

document.querySelector('.nav\_\_link').addEventListener('click', function (e) {
this.style.backgroundColor = randomColor();
});

document.querySelector('.nav\_\_links').addEventListener('click', function (e) {
this.style.backgroundColor = randomColor();
});

document.querySelector('.nav').addEventListener('click', function (e) {
this.style.backgroundColor = randomColor();
});

```

```
When we clicked the link the container also got its own random background color.
The event actually happens at the document root and from there ,then travels down to
the target element, bubbles up = that means that basically it's as if the event had also
happened in all of the parent elements . And so that is the reason why this exact event is
now also being handled by this event listener here that is on nav_links
```

**e.target**

```
is essentially where the event originated.When the event first happened
The target element will always be the same "nav__link"
```

**e.current**

```
The element on which the event handler is attached in the first case is attached to nav**link
and in the nex case is attached to "nav__links".
```

**e.currentTarget === this :**

```
 is exactly the same as the this keyword, so the this keyword is also the one pointing to the element on
 which the eventListener is attached to.
```

## **STOP THE EVENT PROPAGATION**

```
 All we have to do is to simply call on the event , stopPropagation
```

**e.stopPropagation();**

## **THE BUBBLING PHASE**

```
Can be very useful for something called event delegation.
```

## **DEFER AND ASYNC SCRIPT LOADING**

### **REGULAR =**

```
<script src="script.js">

Now in the HTML , We can write the script tag in the document head, or usually at the end of the body .

So when we include a script without any attribute in the head, what will the page loading process look
like over time?
```

## **HEAD**

```
As the user loads the page and receives the HTML , the HTML code will start to be parsed by the browser
and parsing the HTML is basically building the DOM tree from the HTML elements , then at a certain point, it will find  a script tag , start to fetch the script, and then execute it.

During this time the HTML parsing will actually stop , So it will be waiting for the script to get fetched
and executed . Only after that , the rest of the HTML can be parsed and at the end of that parsing, the DOM
content loaded event will finally get fired,
```

```

PARSING HTML /        WAITING       /  FINISH PARSING HTML|
time ===>   /Fetch script - Execute/      DOMContentLoaded|
```

### **BODY**

```
The HTML is parsed then the script tag is found at the end of the document then the script is fetched, And then
finally, the script gets executed.
```

```
PARSING HTML               / Fetch script / Execute
                                          / DOMContentLoaded
```

### **ASYNC =**

```
<script async src ="script.js">
```

### **HEAD**

```
The difference is that the script is loaded at the same time as the HTML is parsed in an asynchronous way,
so that's already an advantage , However, the HTML parsing still stops for the script execution , So the script
is actually downloaded asynchronously , But then it's executed right away in a synchronous way. And the HTML
code has to wait for being parsed .
```

```
PARSING HTML     / Waiting / Finish parsing HTML|
     Fetch script/ Execute /    DOMContentLoaded|
```

### **USE CASES**

```
So one important thing about loading an async script is = Usually the DOMContentLoaded event waits
for all scripts to execute, except for async scripts. So , DOMContentLoaded does not wait for an async script.
```

```
 PARSE HTML        |
       Fetch       |   Run
   DOMContentLoaded|
```

### **DEFER =**

```
<script defer src= "script.js">
```

### **HEAD**

```
The script is still loaded asynchronously, But the execution of the script is deferred until the end of the
HTML parsing , in practice , loading time is similar to the async attribute , but with the key difference
that would defer the HTML parsing is never interrupted , because the script is only executed at the end.
```

### **BODY**

```
Fetching and executing the script, always happens after parsing the HTML anyway , so async and defer
have no practical effect in the body.
```

### **USE CASES**

```
The DOM content loaded event to only get fired after the whole script has been downloaded and executed, And
so this is the more traditional way , that this event works. Another very important aspect is that async
scripts are not guaranteed to be executed in the exact order that they are declared in the code . So the script
that arrives first gets executed first.

By using defer that in not the case , So using the defer attribute guarantees that the scripts are actually
executed in the order that they are declared or written in the code, And that is usually what we want to
happen.

This is overall the best solution! use for your own scripts, and when order matters (e.g including a library)
```

```
PARSE HTML            |
      Fetch       /Run|

```
