# **OLD WAY**

## **IMPLEMENTING SMOOTH SCROLLING**

We need these coordinates here to tell JavaScript where it should scroll to .

```
const btnScrollTo = document.querySelector('.btn--scroll-to');
const section1 = document.querySelector('#section--1');

btnScrollTo.addEventListener('click', function (e) {
const s1coords = section1.getBoundingClientRect();
console.log(
s1coords
);

//_DOMRect {x: 0, y: 276.8000183105469, width: 1524,
height: 1580.425048828125, top: 276.8000183105469, …}_/

console.log(
e.target.getBoundingClientRect()
);

//_DOMRect {x: 187, y: 194.5, width: 110,
height: 27.80000114440918, top: 194.5, …}_/

console.log('Current scroll (X/Y)', window.pageXOffset, window.pageYOffset);
//Current scroll (X/Y) 0 174.39999389648438

console.log(
'height/width viewport',
document.documentElement.clientHeight,
document.documentElement.clientWidth
); // height/width viewport 181 1524

```

## **Scrolling**

## **scrollTo =** That's a global function and is available on the window object.

```
window.scrollTo(
s1coords.left + window.pageXOffset,
s1coords.top + window.pageYOffset
);

// and here the first argument is the left position and that is at s1coords
//current position + current scroll
```

## **Another solution**

//And this works by passing in an object now insted of just one argument

```
window.scrollTo({
left: s1coords.left + window.pageXOffset,
top: s1coords.top + window.pageYOffset,
behavior: 'smooth',
  });
});
```

## **TYPES OF EVENTS AND EVENTS HANDLERS**

```
An event is basically a signal that is generated by a certain note and a signal means that
something has happened for example , a click somewhere or the mouse moving or the user triggering the full
screen mode.
```

**mouseenter event**

```
const h1 = document.querySelector('h1');

//Export function into an named function

const alertH1 = function (e) {
  alert('addEventListener: great ! you are reading the heading');

  //h1.removeEventListener('mouseenter', alertH1);
};
```

```
h1.addEventListener('mouseenter', alertH1); //When we hovered over it , we got the alert.

setTimeout(() => h1.removeEventListener('mouseenter', alertH1), 3000);

h1.onmouseenter = function (e) {
alert('onmouseenter: great ! you are reading the heading');
};
```

## **BUBBLING AND CAPTURING**

```
Javascript events have a very important property, They have a so-called capturing phase and bubbling phase

<body>
  <section>
    <p>A paragraph with a <a>link</a> </p>
    <p>A second paragraph</p>
  </section>
</body>


A click happens on the LINK!
The DOM then generates a click event right away , but this event is actually not generated at the target element.
```

## **1)CAPTURING PHASE**

```
So at the element , where the event happened in this case the click on the anchor element.
Instead, the event is actually generated at the root of the document so at the very top of the DOM tree.
And from there , the so-called capturing phase happens where the event then travels all the way down from
the document root to the target element and as the event travels down the tree it will pass through every single parent element of the target element.

DOCUMENT ==> ELEMENT(html) ==> ELEMENT<body> ==> ELEMENT<section> ==> ELEMENT<p> ==> ELEMENT <a> CLICK EVENT

As soon as the event reaches the target the target phase begins , where events can be handled right at the target and as we already now , we do that with event listeners, such as this one =

document
  .querySelector('a') ====> 127.0.01:8080 says = You clicked me
  .addEventListener('click), ()=> {
    alert('You clicked me');
  });

So event listeners wait for a certain event to happen on a certain element and as soon as the event occurs, it runs the attached callback function
```

## **2) TARGET PHASE **

```
 After reaching the target the event actually travels all the way up to the document route again in the so-called =
```

## **3) BUBBLING PHASE **

```
So we say that events bubble up from the target to the document route , the event passes through all its parents elements

```

**NOTE**

```
By default , events can only be handled in the target and in the bubbling phase, However , we can set up
event listeners in a way that they listen to events in the capturing phase instead.

Also , not all types of events have a capturing and bubbling phase some of them are created right on the target
element , and we can only handle them there
```

## **EVENT PROPAGATION IN PRACTICE**

**rgba(255,255,255)**

```
const randomInt = (min, max) =>
Math.floor(Math.random() \* (max - min + 1) + min);
const randomColor = () =>
`rgba(${randomInt(0, 255)},${randomInt(0, 255)}, ${randomInt(0, 255)})`;

document.querySelector('.nav\_\_link').addEventListener('click', function (e) {
this.style.backgroundColor = randomColor();
});

document.querySelector('.nav\_\_links').addEventListener('click', function (e) {
this.style.backgroundColor = randomColor();
});

document.querySelector('.nav').addEventListener('click', function (e) {
this.style.backgroundColor = randomColor();
});

```

```
When we clicked the link the container also got its own random background color.
The event actually happens at the document root and from there ,then travels down to
the target element, bubbles up = that means that basically it's as if the event had also
happened in all of the parent elements . And so that is the reason why this exact event is
now also being handled by this event listener here that is on nav_links
```

**e.target**

```
is essentially where the event originated.When the event first happened
The target element will always be the same "nav__link"
```

**e.current**

```
The element on which the event handler is attached in the first case is attached to nav**link
and in the nex case is attached to "nav__links".
```

**e.currentTarget === this :**

```
 is exactly the same as the this keyword, so the this keyword is also the one pointing to the element on
 which the eventListener is attached to.
```

## **STOP THE EVENT PROPAGATION **

```
 All we have to do is to simply call on the event , stopPropagation
```

**e.stopPropagation();**

## **THE BUBBLING PHASE **

```
Can be very useful for something called event delegation.
```
